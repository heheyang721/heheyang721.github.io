<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HousePriceAnalysis</title>
      <link href="/2022/11/07/HousePriceAnalysis/"/>
      <url>/2022/11/07/HousePriceAnalysis/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好久没有写blog，为了完成自己给自己定的目标（水一篇blog），我决定开源自己写过的一个小project——链家二手房价预测。仅开源其中数据采集及模型构建的代码。</p><h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><p>撰写链家爬虫代码，以青岛为例（随机选的城市），对每个区的二手房信息以及房价进行爬取，主要运行的技术是requests以及x path解析网页，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_html</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="string">&quot;获取网页源代码&quot;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;cookie&quot;</span>: <span class="string">&quot;自行添加&quot;</span>,</span><br><span class="line">        <span class="string">&quot;user-agent&quot;</span>: <span class="string">&quot;自行添加&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    html = requests.get(url, headers).text</span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">page_phase</span>(<span class="params">html,data,target_location</span>):</span><br><span class="line">    <span class="string">&quot;单页爬取&quot;</span></span><br><span class="line">    tree = etree.HTML(html)</span><br><span class="line">    divs = tree.xpath(<span class="string">&#x27;//div[@class=&quot;info clear&quot;]&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> div <span class="keyword">in</span> divs:</span><br><span class="line">        title = div.xpath(<span class="string">&#x27;.//div[@class=&quot;title&quot;]/a/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        positionInfo = div.xpath(<span class="string">&#x27;.//div[@class=&quot;flood&quot;]/div/a[2]/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        houseInfo = div.xpath(<span class="string">&#x27;.//div[@class=&quot;address&quot;]/div/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        priceInfo = div.xpath(<span class="string">&#x27;.//div[@class=&quot;priceInfo&quot;]/div[2]/span/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        followInfo = div.xpath(<span class="string">&#x27;.//div[@class=&quot;followInfo&quot;]/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        data[<span class="string">&quot;title&quot;</span>].append(title)</span><br><span class="line">        data[<span class="string">&quot;position&quot;</span>].append(positionInfo)</span><br><span class="line">        data[<span class="string">&quot;location&quot;</span>].append(target_location)</span><br><span class="line"></span><br><span class="line">        data[<span class="string">&quot;houseInfo&quot;</span>].append(houseInfo)</span><br><span class="line"></span><br><span class="line">        followInfo_lst = followInfo.split(<span class="string">&quot; / &quot;</span>)</span><br><span class="line">        data[<span class="string">&quot;follow&quot;</span>].append(followInfo_lst[<span class="number">0</span>])</span><br><span class="line">        data[<span class="string">&quot;release time&quot;</span>].append(followInfo_lst[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        data[<span class="string">&quot;price&quot;</span>].append(priceInfo)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;翻页爬取&quot;</span></span><br><span class="line">    target_locations = [<span class="string">&quot;shinan&quot;</span>,<span class="string">&quot;shibei&quot;</span>,<span class="string">&quot;licang&quot;</span>,<span class="string">&quot;laoshan&quot;</span>,<span class="string">&quot;huangdao&quot;</span>,<span class="string">&quot;chengyang&quot;</span>,<span class="string">&quot;jiaozhou&quot;</span>,<span class="string">&quot;jimo&quot;</span>]</span><br><span class="line">    <span class="keyword">global</span> data</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>:[],</span><br><span class="line">        <span class="string">&quot;location&quot;</span>:[],</span><br><span class="line">        <span class="string">&quot;position&quot;</span>:[],</span><br><span class="line">        <span class="string">&quot;houseInfo&quot;</span>:[],</span><br><span class="line">        <span class="string">&quot;follow&quot;</span>:[],</span><br><span class="line">        <span class="string">&quot;release time&quot;</span>:[],</span><br><span class="line">        <span class="string">&quot;price&quot;</span>:[],</span><br><span class="line">    &#125;</span><br><span class="line">    target_location = target_locations[<span class="number">7</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">        target_url = <span class="string">&quot;https://qd.lianjia.com/ershoufang/%s/pg%d/&quot;</span> %(target_location,i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;craweling %s %d页 %s&quot;</span> %(target_location, i, target_url))</span><br><span class="line">        res = get_html(target_url)</span><br><span class="line">        data = page_phase(res,data,target_location)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    df = pd.DataFrame(data)</span><br><span class="line">    df.to_excel(<span class="string">&quot;data/%s.xlsx&quot;</span>%target_location,index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>数据采集结束后，需要对数据进行一定的处理，主要包括：字段分解、数据映射等，这步需要根据自己的理解去进行，因为每个人的模型理解是不一样的，预处理主要是为后续模型构建准备，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_file</span>(<span class="params">path=<span class="string">&quot;data&quot;</span></span>):</span><br><span class="line">    list_dir = os.listdir(path)</span><br><span class="line">    file_path = [os.path.join(path,filename) <span class="keyword">for</span> filename <span class="keyword">in</span> list_dir]</span><br><span class="line">    <span class="keyword">return</span> file_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_data</span>(<span class="params">path</span>):</span><br><span class="line">    df = pd.read_excel(path)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">column_modify</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    字段修改</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 3室2厅 | 123.49平米 | 南 北 | 精装 | 中楼层(共16层) | 2010年建 | 板楼</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getrooms</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            find = re.findall(<span class="string">&quot;(.*?)室&quot;</span>,x)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(find[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> np.NaN</span><br><span class="line">    df[<span class="string">&quot;rooms&quot;</span>] = df[<span class="string">&quot;houseInfo&quot;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: getrooms(x))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getlivings</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            find = re.findall(<span class="string">&quot;室(.*?)厅&quot;</span>,x)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(find[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> np.NaN</span><br><span class="line">    df[<span class="string">&quot;livings&quot;</span>] = df[<span class="string">&quot;houseInfo&quot;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: getlivings(x))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getsquare</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            find = re.findall(<span class="string">&quot; (.*?)平米&quot;</span>,x)</span><br><span class="line">            square = find[<span class="number">0</span>].replace(<span class="string">&quot;| &quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">float</span>(square)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> np.NaN</span><br><span class="line">    df[<span class="string">&quot;square&quot;</span>] = df[<span class="string">&quot;houseInfo&quot;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: getsquare(x))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getorientation</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            orientation = x.split(<span class="string">&quot; | &quot;</span>)[<span class="number">2</span>].split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">            map_lst = &#123;<span class="string">&quot;南&quot;</span>:<span class="number">1</span>,<span class="string">&quot;东南&quot;</span>:<span class="number">1</span>,<span class="string">&quot;西南&quot;</span>:<span class="number">1</span>,<span class="string">&quot;东&quot;</span>:<span class="number">2</span>,<span class="string">&quot;东北&quot;</span>:<span class="number">2</span>,<span class="string">&quot;西&quot;</span>:<span class="number">3</span>,<span class="string">&quot;西北&quot;</span>:<span class="number">3</span>,<span class="string">&quot;北&quot;</span>:<span class="number">3</span>&#125;</span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> map_lst:</span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">in</span> orientation:</span><br><span class="line">                    <span class="keyword">return</span> map_lst[key]</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    df[<span class="string">&quot;orientation&quot;</span>] = df[<span class="string">&quot;houseInfo&quot;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: getorientation(x))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getdecoration</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="built_in">type</span> = x.split(<span class="string">&quot; | &quot;</span>)[<span class="number">3</span>]</span><br><span class="line">        map_lst = &#123;<span class="string">&quot;精装&quot;</span>:<span class="number">1</span>, <span class="string">&quot;简装&quot;</span>:<span class="number">2</span>, <span class="string">&quot;毛坯&quot;</span>:<span class="number">3</span>, <span class="string">&quot;其他&quot;</span>:<span class="number">4</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> map_lst[<span class="built_in">type</span>]</span><br><span class="line">    df[<span class="string">&quot;decoration type&quot;</span>] = df[<span class="string">&quot;houseInfo&quot;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: getdecoration(x))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getfloor</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            find = re.findall(<span class="string">&quot;(\d+)层&quot;</span>,x)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(find[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> np.NaN</span><br><span class="line">    df[<span class="string">&quot;floor&quot;</span>] = df[<span class="string">&quot;houseInfo&quot;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: getfloor(x))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getyear</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            find = re.findall(<span class="string">&quot;(\d+)年&quot;</span>,x)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(find[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> np.NaN</span><br><span class="line">    df[<span class="string">&quot;year&quot;</span>] = df[<span class="string">&quot;houseInfo&quot;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: getyear(x))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getbuliding</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="built_in">type</span> = x.split(<span class="string">&quot; | &quot;</span>)[-<span class="number">1</span>].replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> == <span class="string">&quot;暂无数据&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        map_list = &#123;<span class="string">&quot;平房&quot;</span>:<span class="number">1</span>, <span class="string">&quot;板楼&quot;</span>:<span class="number">2</span>, <span class="string">&quot;板塔结合&quot;</span>:<span class="number">3</span>, <span class="string">&quot;塔楼&quot;</span>:<span class="number">4</span>, <span class="string">&quot;联排别墅&quot;</span>:<span class="number">5</span>, <span class="string">&quot;叠拼别墅&quot;</span>:<span class="number">6</span>, <span class="string">&quot;双拼别墅&quot;</span>:<span class="number">7</span>, <span class="string">&quot;独栋别墅&quot;</span>:<span class="number">8</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> map_list[<span class="built_in">type</span>]</span><br><span class="line">    df[<span class="string">&quot;buliding type&quot;</span>] = df[<span class="string">&quot;houseInfo&quot;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: getbuliding(x))</span><br><span class="line"></span><br><span class="line">    df[<span class="string">&quot;follow&quot;</span>] = df[<span class="string">&quot;follow&quot;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(re.findall(<span class="string">&quot;(\d+)人&quot;</span>,x)[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_time</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;天&quot;</span> <span class="keyword">in</span> x:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(re.findall(<span class="string">&quot;(\d+)天&quot;</span>,x)[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&quot;月&quot;</span> <span class="keyword">in</span> x:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(re.findall(<span class="string">&quot;(\d+)个月&quot;</span>, x)[<span class="number">0</span>])*<span class="number">30</span>+random.randint(<span class="number">0</span>,<span class="number">30</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">365</span>+random.randint(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">    df[<span class="string">&quot;release time&quot;</span>] = df[<span class="string">&quot;release time&quot;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: get_time(x))</span><br><span class="line"></span><br><span class="line">    df[<span class="string">&quot;price&quot;</span>] = df[<span class="string">&quot;price&quot;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: re.findall(<span class="string">&quot;(\d+)元&quot;</span>,x.replace(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;&quot;</span>))[<span class="number">0</span>])</span><br><span class="line">    df = df.loc[:,[<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;location&#x27;</span>, <span class="string">&#x27;position&#x27;</span>, <span class="string">&#x27;rooms&#x27;</span>, <span class="string">&#x27;livings&#x27;</span>, <span class="string">&#x27;square&#x27;</span>, <span class="string">&#x27;orientation&#x27;</span>, <span class="string">&#x27;decoration type&#x27;</span>, <span class="string">&#x27;floor&#x27;</span>, <span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;buliding type&#x27;</span>,<span class="string">&#x27;follow&#x27;</span>, <span class="string">&#x27;release time&#x27;</span>, <span class="string">&#x27;price&#x27;</span>]]</span><br><span class="line">    <span class="built_in">print</span>(df.columns)</span><br><span class="line">    df.to_excel(<span class="string">&quot;all_data.xlsx&quot;</span>,index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    file_path = get_file()</span><br><span class="line">    df = read_data(file_path[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(file_path)):</span><br><span class="line">        df = pd.concat([df,read_data(file_path[i])])</span><br><span class="line">    df.reset_index(inplace=<span class="literal">True</span>)</span><br><span class="line">    df = df.drop([<span class="string">&quot;index&quot;</span>],axis=<span class="number">1</span>)</span><br><span class="line">    column_modify(df)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h2><p>主要构建了多元线性回归及随机森林回归，并比较其模型的效果。模型构建前，包括一些简单的模型准备工作：数据清洗、变量编码、特征选取。代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score,mean_squared_error</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Arial Unicode MS&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_data</span>(<span class="params">path=<span class="string">&quot;all_data.xlsx&quot;</span></span>):</span><br><span class="line">    <span class="keyword">return</span> pd.read_excel(path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_cleaning</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;###############数据清洗#################&quot;</span>)</span><br><span class="line">    <span class="comment"># 删除缺失值</span></span><br><span class="line">    df = df.dropna(axis=<span class="number">0</span>, how=<span class="string">&quot;any&quot;</span>)</span><br><span class="line">    <span class="comment"># 删除房价异常值</span></span><br><span class="line">    <span class="built_in">print</span>(df[<span class="string">&quot;price&quot;</span>].describe())</span><br><span class="line">    <span class="comment"># 房价太高影响拟和</span></span><br><span class="line">    df = df[df[<span class="string">&quot;price&quot;</span>]&lt;=<span class="number">100000</span>]</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">feature_select</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;###############特征选取#################&quot;</span>)</span><br><span class="line">    cor = df.corr()</span><br><span class="line">    <span class="built_in">print</span>(cor)</span><br><span class="line">    plt.figure(dpi=<span class="number">300</span>,figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">    sns.heatmap(cor, annot=<span class="literal">True</span>, vmax=<span class="number">1</span>, vmin=<span class="number">0</span>, xticklabels=<span class="literal">True</span>, yticklabels=<span class="literal">True</span>, square=<span class="literal">True</span>, cmap=<span class="string">&quot;YlGnBu&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;相关系数热力图&quot;</span>)</span><br><span class="line">    plt.savefig(<span class="string">&quot;output/相关系数热力图.png&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="comment"># one hot 编码</span></span><br><span class="line">    df = df.drop(labels = [<span class="string">&quot;title&quot;</span>,<span class="string">&quot;position&quot;</span>], axis=<span class="number">1</span>)</span><br><span class="line">    df = pd.get_dummies(df)</span><br><span class="line">    <span class="built_in">print</span>(df.drop(labels=<span class="string">&quot;price&quot;</span>, axis=<span class="number">1</span>).columns)</span><br><span class="line">    x = df.drop(labels=<span class="string">&quot;price&quot;</span>, axis=<span class="number">1</span>).values</span><br><span class="line">    y = df[<span class="string">&quot;price&quot;</span>].values</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> X_train, X_test, y_train, y_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model_line</span>(<span class="params">X_train, X_test, y_train, y_test</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;###############多元线性回归#################&quot;</span>)</span><br><span class="line">    regr = LinearRegression()</span><br><span class="line">    regr.fit(X_train,y_train)</span><br><span class="line">    <span class="comment"># 构造返回字典</span></span><br><span class="line">    predictions = &#123;&#125;</span><br><span class="line">    <span class="comment"># 截距值</span></span><br><span class="line">    predictions[<span class="string">&#x27;intercept&#x27;</span>] = regr.intercept_</span><br><span class="line">    <span class="comment"># 回归系数（斜率值）</span></span><br><span class="line">    predictions[<span class="string">&#x27;coefficient&#x27;</span>] = regr.coef_</span><br><span class="line">    <span class="comment"># 预测</span></span><br><span class="line">    pre_train = regr.predict(X_train)</span><br><span class="line">    pre_test = regr.predict(X_test)</span><br><span class="line">    predictions[<span class="string">&quot;train r2&quot;</span>] = r2_score(pre_train,y_train)</span><br><span class="line">    predictions[<span class="string">&quot;test r2&quot;</span>] = r2_score(pre_test,y_test)</span><br><span class="line">    pprint(predictions)</span><br><span class="line">    Nums=<span class="number">200</span></span><br><span class="line">    x = <span class="built_in">range</span>(<span class="number">1</span>,Nums+<span class="number">1</span>)</span><br><span class="line">    plt.scatter(x,y_test[:Nums],marker=<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    plt.plot(x,pre_test[:Nums],c=<span class="string">&quot;r&quot;</span>,label=<span class="string">&quot;pre&quot;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;price&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;线性回归预测图&quot;</span>)</span><br><span class="line">    plt.savefig(<span class="string">&quot;output/线性回归预测图.png&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model_rf</span>(<span class="params">X_train, X_test, y_train, y_test</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;###############随机森林回归#################&quot;</span>)</span><br><span class="line">    regr = RandomForestRegressor(n_estimators=<span class="number">500</span>,max_depth=<span class="number">10</span>,criterion=<span class="string">&#x27;mse&#x27;</span>,random_state=<span class="number">1</span>,n_jobs=-<span class="number">1</span>)</span><br><span class="line">    regr.fit(X_train,y_train)</span><br><span class="line">    <span class="comment"># 构造返回字典</span></span><br><span class="line">    predictions = &#123;&#125;</span><br><span class="line">    predictions[<span class="string">&#x27;type of rf&#x27;</span>] = <span class="string">&quot;regression&quot;</span></span><br><span class="line">    predictions[<span class="string">&#x27;Number of trees&#x27;</span>] = <span class="number">500</span></span><br><span class="line">    predictions[<span class="string">&#x27;Max depth of trees&#x27;</span>] = <span class="number">10</span></span><br><span class="line">    <span class="comment"># 预测</span></span><br><span class="line">    pre_train = regr.predict(X_train)</span><br><span class="line">    pre_test = regr.predict(X_test)</span><br><span class="line">    predictions[<span class="string">&#x27;mean squared error&#x27;</span>] = mean_squared_error(pre_train,y_train)</span><br><span class="line">    predictions[<span class="string">&quot;train r2&quot;</span>] = r2_score(pre_train,y_train)</span><br><span class="line">    predictions[<span class="string">&quot;test r2&quot;</span>] = r2_score(pre_test,y_test)</span><br><span class="line">    pprint(predictions)</span><br><span class="line">    Nums=<span class="number">200</span></span><br><span class="line">    x = <span class="built_in">range</span>(<span class="number">1</span>,Nums+<span class="number">1</span>)</span><br><span class="line">    plt.scatter(x,y_test[:Nums],marker=<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    plt.plot(x,pre_test[:Nums],c=<span class="string">&quot;r&quot;</span>,label=<span class="string">&quot;pre&quot;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;price&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;随机森林回归预测图&quot;</span>)</span><br><span class="line">    plt.savefig(<span class="string">&quot;output/随机森林回归预测图.png&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    df = read_data()</span><br><span class="line">    df = data_cleaning(df)</span><br><span class="line">    X_train, X_test, y_train, y_test = feature_select(df)</span><br><span class="line">    model_line(X_train, X_test, y_train, y_test)</span><br><span class="line">    model_rf(X_train, X_test, y_train, y_test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>结果我就不放了，有需要的自己跑一下就ok了，代码是非常详细的。ps：最近首页增加了一个故事模块，个人觉得非常nice，提醒一下大家。以上，感谢观看！</p>]]></content>
      
      
      <categories>
          
          <category> Reptile, Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reptile </tag>
            
            <tag> Multiple linear regression </tag>
            
            <tag> Random forest regression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于pytorch的LSTM多维序列预测</title>
      <link href="/2022/10/11/LSTM/"/>
      <url>/2022/10/11/LSTM/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​         羊最近碰到了多维度的时间序列问题，经过我一番查资料发现解决这类问题往上大多数为两类方法，一种是以ARIMAX为代表的自回归时间序列模型，通过对序列数据自回归，得到数据的时序趋势特征，进而实现时间序列预测。但是在我查看的所有样例中，几乎都是针对单维数据建构的，我没有找到一种兼容多维数据的自回归方法，如果大家有好的方法推荐，欢迎和我交流。</p><p>​        所以这时候我把目光转向第二种办法——深度学习，当然有一定基础的我（有点基础，但是不多），不会整原始的循环神经网络RNN，因为普通的RNN很难训练的，其在实际应用中，很难处理长距离的依赖。我把目标转向长短期记忆网络LSTM，话不多说，开整！</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>​        已知一段时间某个地区的空气污染质量指标，其中包括’aqi’, ‘pm2_5’, ‘pm10’, ‘so2’, ‘no2’, ‘co’, ‘o3’相关指标，根据现有的数据构建LSTM预测未来24小时内的空气污染质量指标。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol><li>数据准备</li></ol><p>​        数据准备作为模型构建的基础，也是本人code最长时间的部分，不同数据的数据处理不同，有点基础的我按照传统逻辑进行数据准备，主要包括：获取数据，数据清洗，数据标准化，滑窗取样，数据分割，数据集生成。</p><p>​        tips：这里的一些处理步骤名词，有的可能只是我个人理解说的词，如果您有更加专业的可以和我交流，主页有邮箱呦。</p><p>​        代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_path</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取数据路径</span></span><br><span class="line"><span class="string">    :param path:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    files = os.listdir(path)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;气象&quot;</span> <span class="keyword">in</span> file:</span><br><span class="line">            df_weather = pd.read_excel(os.path.join(path,file))</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&quot;空气质量&quot;</span> <span class="keyword">in</span> file:</span><br><span class="line">            df_air = pd.read_excel(os.path.join(path,file))</span><br><span class="line">    df = pd.merge(df_air, df_weather, on=[<span class="string">&quot;time&quot;</span>, <span class="string">&quot;cityname&quot;</span>])</span><br><span class="line">    df = df[df[<span class="string">&quot;cityname&quot;</span>] == <span class="string">&quot;许昌&quot;</span>]</span><br><span class="line">    df.to_excel(os.path.join(path, path+<span class="string">&quot;.xlsx&quot;</span>), index=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">return</span> os.path.join(path, path+<span class="string">&quot;.xlsx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取数据</span></span><br><span class="line"><span class="string">    :param path:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    df = pd.read_excel(path)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_process</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    数据清洗</span></span><br><span class="line"><span class="string">    :param df:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 删除city_name</span></span><br><span class="line">    columns = <span class="built_in">list</span>(df.columns)</span><br><span class="line">    columns.remove(<span class="string">&quot;cityname&quot;</span>)</span><br><span class="line">    df = df.loc[:,columns]</span><br><span class="line">    df.set_index(<span class="string">&quot;time&quot;</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># wind one-hot编码</span></span><br><span class="line">    df = pd.get_dummies(df,prefix=<span class="string">&quot;winddirection&quot;</span>)</span><br><span class="line">    <span class="comment"># 缺失值删除</span></span><br><span class="line">    df = df.dropna(axis=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 获取label</span></span><br><span class="line">    label = df.loc[:,[<span class="string">&#x27;aqi&#x27;</span>, <span class="string">&#x27;pm2_5&#x27;</span>, <span class="string">&#x27;pm10&#x27;</span>, <span class="string">&#x27;so2&#x27;</span>, <span class="string">&#x27;no2&#x27;</span>, <span class="string">&#x27;co&#x27;</span>, <span class="string">&#x27;o3&#x27;</span>]]</span><br><span class="line">    <span class="keyword">return</span> df,label</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">normalization</span>(<span class="params">data,label</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    标准化</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :param label:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    mm_x = MinMaxScaler()</span><br><span class="line">    mm_y = MinMaxScaler()</span><br><span class="line">    data = data.values</span><br><span class="line">    data = mm_x.fit_transform(data)</span><br><span class="line">    label = mm_y.fit_transform(label)</span><br><span class="line">    <span class="built_in">print</span>(label.shape)</span><br><span class="line">    <span class="keyword">return</span> data, label, mm_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_windows</span>(<span class="params">data,label,seq_length,time_seq</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构建训练数据，LSTM的x,y</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :param seq_length:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data) - seq_length - time_seq):</span><br><span class="line">        _x = data[i:(i + seq_length), :]</span><br><span class="line">        _y = label[(i+seq_length):(i+seq_length+time_seq),:]</span><br><span class="line">        _y = np.array(_y).flatten().tolist()</span><br><span class="line">        x.append(_x)</span><br><span class="line">        y.append(_y)</span><br><span class="line">    x, y = np.array(x), np.array(y)</span><br><span class="line">    <span class="keyword">return</span> x, y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_split</span>(<span class="params">x, y, split_ratio</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    数据分割</span></span><br><span class="line"><span class="string">    :param x:</span></span><br><span class="line"><span class="string">    :param y:</span></span><br><span class="line"><span class="string">    :param split_ratio:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    train_size = <span class="built_in">int</span>(<span class="built_in">len</span>(y) * split_ratio)</span><br><span class="line">    test_size = <span class="built_in">len</span>(y) - train_size</span><br><span class="line"></span><br><span class="line">    x_data = Variable(torch.Tensor(np.array(x)))</span><br><span class="line">    y_data = Variable(torch.Tensor(np.array(y)))</span><br><span class="line"></span><br><span class="line">    x_train = Variable(torch.Tensor(np.array(x[<span class="number">0</span>:train_size])))</span><br><span class="line">    y_train = Variable(torch.Tensor(np.array(y[<span class="number">0</span>:train_size])))</span><br><span class="line">    x_test = Variable(torch.Tensor(np.array(x[train_size:<span class="built_in">len</span>(x)])))</span><br><span class="line">    y_test = Variable(torch.Tensor(np.array(y[train_size:<span class="built_in">len</span>(y)])))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x_train.shape,y_train.shape,x_test.shape,y_test.shape:\n&#x27;</span>, x_train.shape, y_train.shape, x_test.shape,</span><br><span class="line">          y_test.shape)</span><br><span class="line">    <span class="keyword">return</span> x_data, y_data, x_train, y_train, x_test, y_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_generator</span>(<span class="params">x_train, y_train, x_test, y_test, n_iters, batch_size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    数据生成</span></span><br><span class="line"><span class="string">    :param x_train:</span></span><br><span class="line"><span class="string">    :param y_train:</span></span><br><span class="line"><span class="string">    :param x_test:</span></span><br><span class="line"><span class="string">    :param y_test:</span></span><br><span class="line"><span class="string">    :param n_iters:</span></span><br><span class="line"><span class="string">    :param batch_size:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num_epochs = n_iters / (<span class="built_in">len</span>(x_train) / batch_size)</span><br><span class="line">    num_epochs = <span class="built_in">int</span>(num_epochs)</span><br><span class="line">    train_dataset = Data.TensorDataset(x_train, y_train)</span><br><span class="line">    test_dataset = Data.TensorDataset(x_test, y_test)</span><br><span class="line">    train_loader = torch.utils.data.DataLoader(dataset=train_dataset,</span><br><span class="line">                                               batch_size=batch_size,</span><br><span class="line">                                               shuffle=<span class="literal">False</span>)</span><br><span class="line">    test_loader = torch.utils.data.DataLoader(dataset=test_dataset,</span><br><span class="line">                                              batch_size=batch_size,</span><br><span class="line">                                              shuffle=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">return</span> train_loader, test_loader, num_epochs</span><br></pre></td></tr></table></figure><ol start="2"><li>LSTM模型构建</li></ol><p>​        该部分就是构建LSTM的NET，参数包括输入大小 input_size，输出大小output_size，隐藏层大小hidden_size，网络层数num_layers，预测时长seq_length，主要是由LSTM层和全连接层构成，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LSTM</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, output_size, input_size, hidden_size, num_layers,seq_length</span>):</span><br><span class="line">        <span class="built_in">super</span>(LSTM, self).__init__()</span><br><span class="line">        self.num_classes = output_size</span><br><span class="line">        self.num_layers = num_layers</span><br><span class="line">        self.input_size = input_size</span><br><span class="line">        self.hidden_size = hidden_size</span><br><span class="line">        self.seq_length = seq_length</span><br><span class="line">        self.lstm = nn.LSTM(input_size=input_size, hidden_size=hidden_size,</span><br><span class="line">                            num_layers=num_layers, batch_first=<span class="literal">True</span>)</span><br><span class="line">        self.fc = nn.Linear(hidden_size, output_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        h_0 = Variable(torch.zeros(</span><br><span class="line">            self.num_layers, x.size(<span class="number">0</span>), self.hidden_size))</span><br><span class="line">        c_0 = Variable(torch.zeros(</span><br><span class="line">            self.num_layers, x.size(<span class="number">0</span>), self.hidden_size))</span><br><span class="line">        <span class="comment"># Propagate input through LSTM</span></span><br><span class="line">        ula, (h_out, _) = self.lstm(x, (h_0, c_0))</span><br><span class="line">        h_out = h_out.view(-<span class="number">1</span>, self.hidden_size)</span><br><span class="line">        out = self.fc(h_out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><ol start="3"><li>模型训练及评价</li></ol><p>​        设定MSE损失函数，以及Adam优化器进行传播训练，并计算准确率以及相关系数进行评价，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">model_train</span>(<span class="params">num_epochs,train_loader,model,optimizer,criterion</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    模型训练</span></span><br><span class="line"><span class="string">    :param num_epochs:</span></span><br><span class="line"><span class="string">    :param train_loader:</span></span><br><span class="line"><span class="string">    :param model:</span></span><br><span class="line"><span class="string">    :param optimizer:</span></span><br><span class="line"><span class="string">    :param criterion:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Training</span></span><br><span class="line">    <span class="built_in">iter</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> epochs <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> i, (batch_x, batch_y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">            outputs = model(batch_x)</span><br><span class="line">            <span class="comment"># clear the gradients</span></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            <span class="comment"># loss</span></span><br><span class="line">            loss = criterion(outputs, batch_y)</span><br><span class="line">            <span class="comment"># backpropagation</span></span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            <span class="built_in">iter</span> += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">iter</span> % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;iter: %d, loss: %1.5f&quot;</span> % (<span class="built_in">iter</span>, loss.item()))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_acc</span>(<span class="params">lst1,lst2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算准确率</span></span><br><span class="line"><span class="string">    :param lst1:</span></span><br><span class="line"><span class="string">    :param lst2:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lst1)):</span><br><span class="line">        <span class="keyword">if</span> lst1[i] &lt;= (lst2[i]*<span class="number">1.2</span>) <span class="keyword">and</span> lst1[i] &gt;= (lst2[i]*<span class="number">0.8</span>):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count/<span class="built_in">len</span>(lst1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">result</span>(<span class="params">x_data, y_data, model, mm_y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    结果分析</span></span><br><span class="line"><span class="string">    :param x_data:</span></span><br><span class="line"><span class="string">    :param y_data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    data_pre = model(x_data)</span><br><span class="line">    pre = data_pre.detach().numpy()</span><br><span class="line">    y = y_data.detach().numpy()</span><br><span class="line">    corr_scores = []</span><br><span class="line">    acc = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pre)):</span><br><span class="line">        s1 = pd.Series(pre[i])</span><br><span class="line">        s2 = pd.Series(y[i])</span><br><span class="line">        corr = s1.corr(s2)</span><br><span class="line">        corr_scores.append(corr)</span><br><span class="line">        count = count_acc(pre[i],y[i])</span><br><span class="line">        acc.append(count)</span><br><span class="line">    plt.plot(corr_scores)</span><br><span class="line">    plt.plot(acc)</span><br><span class="line">    plt.legend((<span class="string">&#x27;corr&#x27;</span>, <span class="string">&#x27;acc&#x27;</span>), fontsize=<span class="string">&#x27;15&#x27;</span>)</span><br><span class="line">    plt.savefig(<span class="string">&quot;corr_r2.png&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;#################model evaluate##################&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;pearson score: %.4f&quot;</span> %np.mean(corr_scores))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;acc score: %.4f&quot;</span> %np.mean(acc))</span><br></pre></td></tr></table></figure><p>​        本人用自用电脑跑的，所以传播次数有限，最后得到相关结果如下：</p><p><img src="/2022/10/11/LSTM/result.png" alt="运行结果图"></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeuralNetwork </tag>
            
            <tag> LSTM </tag>
            
            <tag> Prediction </tag>
            
            <tag> MultiSequence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS conda配置StanfordCoreNLP实现NER</title>
      <link href="/2022/09/04/stanfordcorenlp/"/>
      <url>/2022/09/04/stanfordcorenlp/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        不知道大家是不是和我使用macOS感受一样，装个库问题百出，网上教程还少，stanfordcorenlp就是这些刺头之一，虽然麻烦但是通过努力也算是成功实现了我起初的目的，在此记录一下。</p><p>​        首先介绍一下stanfordcorenlp，它是一个自然语言处理工具包，其集成了很多非常实用的功能，包括分词，词性标注，句法分析等等。它就是把训练好的模型封装起来，方便大家的使用，实际上可以类比为一个软件。目前市面上有不少类似的工具，结巴分词、清华、哈工大等等。</p><p>​        那么我为什么选择stanfordcorenlp呢？理由网上给了三点，我给出一点：</p><ol><li><p>功能足够多，一站式解决所有主流需求；</p></li><li><p>操作足够方便，放到 Python 里基本上就是一两行代码；</p></li><li><p>语言支持广泛，目前支持阿拉伯语，中文，英文，法语，德语，西班牙语，做平行语料的对比非常方便；</p></li><li><p>我自身体验下来，最后关键一点，运行快。</p></li></ol><h2 id="个人电脑配置"><a href="#个人电脑配置" class="headerlink" title="个人电脑配置"></a>个人电脑配置</h2><ol><li>系统：macOS Monterey</li><li>conda环境，python3.9</li><li>java version “17.0.2”，无java环境需提前配置java环境</li></ol><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><ol><li>安装stanfordcorenlp库</li></ol><p>​        这里通过实测，推荐使用pip进行安装，虚拟环境没有pip的先安装pip，安装代码如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install stanfordcorenlp==3.8.0.1</span><br></pre></td></tr></table></figure><p>​       一定要设置版本号，默认版本为3.9，在后续测试中存在问题，推荐3.8.0.1版本。安装成功后，在虚拟环境site-packages中存在stanfordcorenlp文件夹，其中包含一个corenlp.py文件，步骤4需要。</p><ol start="2"><li>下载StanfordCoreNLP文件及中文模型jar包</li></ol><p>​        前往官网下载两个文件，经过本人测试最新版本在后续配置中存在问题，这里推荐为3.9.0版本，版本发布日期为2018-01-31，并下载中文jar包，如下所示：</p><p><img src="https://s2.loli.net/2022/09/04/X1W9GialsgqjNE4.png" alt="下载界面.png"></p><p><a href="https://stanfordnlp.github.io/CoreNLP/history.html">CoreNLP文件及模型jar包下载地址</a></p><ol start="3"><li>配置文件</li></ol><p>​       两个文件下载好后，你将得到两个文件，stanford-corenlp-full-2018-01-31.zip以及stanford-chinese-corenlp-2018-01-31-models.jar，对于zip文件需要解压放入任意文件夹，然后把模型jar包放入解压后的stanford-corenlp-full-2018-01-31文件夹中。</p><ol start="4"><li>代码实现NER</li></ol><p>​        以上StanfordCoreNLP算是配置好了，这个时候我们还需要去步骤1中的corenlp.py文件中84，85行代码注释掉，如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Check if the port is in use</span></span><br><span class="line"><span class="keyword">if</span> self.port <span class="keyword">in</span> [conn.laddr[<span class="number">1</span>] <span class="keyword">for</span> conn <span class="keyword">in</span> psutil.net_connections()]:</span><br><span class="line">    <span class="keyword">raise</span> IOError(<span class="string">&#x27;Port &#x27;</span> + <span class="built_in">str</span>(self.port) + <span class="string">&#x27; is already in use.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​       以上就可以实现NER了测试demo如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> stanfordcorenlp <span class="keyword">import</span> StanfordCoreNLP</span><br><span class="line"><span class="comment"># 修改stanford-corenlp-full-2018-01-31所在的path，port一定要写</span></span><br><span class="line">zh_model = StanfordCoreNLP(<span class="string">r&#x27;/your_path/stanford-corenlp-full-2018-01-31&#x27;</span>, lang=<span class="string">&#x27;zh&#x27;</span>,port=<span class="number">9999</span>)</span><br><span class="line">sentence = <span class="string">&quot;我在福建，我爱中国&quot;</span></span><br><span class="line"><span class="comment"># 分词</span></span><br><span class="line"><span class="built_in">print</span>(zh_model.word_tokenize(sentence))</span><br><span class="line"><span class="comment"># 词性标注</span></span><br><span class="line"><span class="built_in">print</span>(zh_model.pos_tag(sentence))</span><br><span class="line"><span class="comment"># NER</span></span><br><span class="line"><span class="built_in">print</span>(zh_model.ner(sentence))</span><br></pre></td></tr></table></figure><p>​        结果如下图所示：</p><p><img src="https://s2.loli.net/2022/09/04/gnGdpUHBQtcIT3K.png" alt="截屏2022-09-04 23.53.53.png"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>​        该博客为个人学习使用，欢迎大家在主页关注我的git-hub，欢迎大家多多交流关注，如有问题欢迎邮件！</p><p><img src="https://s2.loli.net/2022/09/05/lC4RcV3pZDEh8Ff.png" alt="截屏2022-09-04 23.59.18.png"></p>]]></content>
      
      
      <categories>
          
          <category> conda配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> conda </tag>
            
            <tag> NER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>helloworld</title>
      <link href="/2022/08/28/helloworld/"/>
      <url>/2022/08/28/helloworld/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
